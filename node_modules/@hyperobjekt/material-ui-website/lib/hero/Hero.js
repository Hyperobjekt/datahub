"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Hero = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _clsx = _interopRequireDefault(require("clsx"));

var _block = _interopRequireDefault(require("../block"));

var _core = require("@material-ui/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var styles = function styles(theme) {
  return {
    root: {
      display: "flex",
      position: "relative",
      minHeight: 420,
      overflow: "hidden"
    },
    container: {},
    imageWrapper: {
      position: "relative",
      zIndex: 2
    },
    image: {
      display: "block",
      width: "auto",
      maxWidth: "100%"
    },
    content: {
      position: "relative",
      zIndex: 2
    },
    gradient: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: "100%",
      height: "100%",
      zIndex: 1
    },
    overlay: {
      "& $imageWrapper": {
        position: "absolute",
        left: 0,
        right: 0,
        bottom: 0,
        top: 0,
        overflow: "hidden",
        zIndex: 1
      },
      "& $image": {
        margin: "auto",
        objectFit: "cover",
        width: "100%",
        height: "100%"
      }
    }
  };
};
/**
 * The Hero component is used to create a callout section that draws attention, usually at the top of the page.
 *
 * All props that are not specific to the Hero component are passed down to the Block component.
 */


var Hero = function Hero(_ref) {
  var classes = _ref.classes,
      children = _ref.children,
      align = _ref.align,
      image = _ref.image,
      gradient = _ref.gradient,
      _ref$alt = _ref.alt,
      alt = _ref$alt === void 0 ? "" : _ref$alt,
      variant = _ref.variant,
      _ref$ContainerProps = _ref.ContainerProps,
      ContainerProps = _ref$ContainerProps === void 0 ? {} : _ref$ContainerProps,
      props = _objectWithoutProperties(_ref, ["classes", "children", "align", "image", "gradient", "alt", "variant", "ContainerProps"]);

  var gradientString = Array.isArray(gradient) ? "linear-gradient(".concat(gradient.join(","), ")") : gradient;

  var containerProps = _objectSpread({
    align: align,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-around"
  }, ContainerProps);

  console.log("cp", ContainerProps, containerProps);
  return /*#__PURE__*/_react["default"].createElement(_block["default"], _extends({
    classes: {
      root: (0, _clsx["default"])(classes.root, classes[variant]),
      container: classes.container
    },
    bgcolor: "primary.main",
    color: "primary.contrastText",
    ContainerProps: containerProps
  }, props), /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.content
  }, children), image && /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.imageWrapper
  }, /*#__PURE__*/_react["default"].createElement("img", {
    className: classes.image,
    src: image,
    alt: alt
  })), gradientString && /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.gradient,
    style: {
      background: gradientString
    }
  }));
};

exports.Hero = Hero;
Hero.propTypes = {
  /**
   * Classname overrides (valid keys: `root`, `container`, `imageWrapper`, `image`, `content`, `gradient`, `overlay` )
   */
  classes: _propTypes["default"].object,

  /**
   * URL or path to the image to use in the hero
   */
  image: _propTypes["default"].string,

  /**
   * Alt text to use for the image
   */
  alt: _propTypes["default"].string,

  /**
   * Determines the layout for the hero.  Currently `overlay` is the only available variant.
   */
  variant: _propTypes["default"].string,

  /**
   * A CSS gradient string, or alternatively an array of linear-gradient properties.  Use a gradient creator to make things easier: ([components.ai](https://components.ai/gradient/), [cssgradient.io](https://cssgradient.io/))
   */
  gradient: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array]),

  /**
   * Props passed to the Container component
   */
  ContainerProps: _propTypes["default"].object,

  /**
   * Optional alignment for the content (e.g. "center")
   */
  align: _propTypes["default"].string
};
Hero.__docgenInfo = {
  "description": "The Hero component is used to create a callout section that draws attention, usually at the top of the page.\n\nAll props that are not specific to the Hero component are passed down to the Block component.",
  "methods": [],
  "displayName": "Hero",
  "props": {
    "alt": {
      "defaultValue": {
        "value": "\"\"",
        "computed": false
      },
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "Alt text to use for the image"
    },
    "ContainerProps": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "type": {
        "name": "object"
      },
      "required": false,
      "description": "Props passed to the Container component"
    },
    "classes": {
      "type": {
        "name": "object"
      },
      "required": false,
      "description": "Classname overrides (valid keys: `root`, `container`, `imageWrapper`, `image`, `content`, `gradient`, `overlay` )"
    },
    "image": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "URL or path to the image to use in the hero"
    },
    "variant": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "Determines the layout for the hero.  Currently `overlay` is the only available variant."
    },
    "gradient": {
      "type": {
        "name": "union",
        "value": [{
          "name": "string"
        }, {
          "name": "array"
        }]
      },
      "required": false,
      "description": "A CSS gradient string, or alternatively an array of linear-gradient properties.  Use a gradient creator to make things easier: ([components.ai](https://components.ai/gradient/), [cssgradient.io](https://cssgradient.io/))"
    },
    "align": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "Optional alignment for the content (e.g. \"center\")"
    }
  }
};
var exportComponent = (0, _core.withStyles)(styles)(Hero); // copy static props for storybook

if (process.env.NODE_ENV !== "production") {
  exportComponent.displayName = Hero.displayName;
  exportComponent.propTypes = Hero.propTypes;
  exportComponent.defaultProps = Hero.defaultProps;
}

var _default = exportComponent;
exports["default"] = _default;